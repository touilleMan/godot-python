cimport cython

from .hazmat.gdapi cimport *
from .builtins cimport *

cdef class BaseGDObject:
    def free(self):
        pythonscript_gdextension.object_destroy(self._gd_ptr)
        self._gd_ptr = NULL

    def __init__(self):
        raise RuntimeError(
            f"Use `new()` method to instantiate non-refcounted Godot object (and don't forget to free it !)"
        )

    def __repr__(self):
        return f"<{type(self).__name__} wrapper on 0x{<size_t>self._gd_ptr:x}>"

    @staticmethod
    cdef BaseGDObject from_ptr(GDExtensionObjectPtr ptr):
        # Call to __new__ bypasses __init__ constructor
        cdef BaseGDObject wrapper = BaseGDObject.__new__(BaseGDObject)
        wrapper._gd_ptr = ptr
        # Note if the object is a reference, we stole it from the caller given we
        # don't call `Reference.reference` here
        return wrapper

    def _set_gd_ptr(self, ptr):
        # /!\ doing `<GDExtensionObjectPtr>ptr` would return the address of
        # the PyObject instead of casting it value !
        self._gd_ptr = <GDExtensionObjectPtr><size_t>ptr
        # Note if the object is a reference, we stole it from the caller given we
        # don't call `Reference.reference` here

    @classmethod
    def _from_ptr(cls, ptr):
        cdef object wrapper = cls.__new__(cls)
        wrapper._set_gd_ptr(ptr)
        return wrapper

{# {% for klass in api.classes %} #}
{#  #}
{#  #}
{# cdef class {{ klass.cy_type }}({{ klass.inherits.cy_type if klass.inherits else "" }}): #}
{# {%   if klass.inherits is none %} #}
{#  #}
{#     {# @staticmethod #}
{#     cpdef inline {{ klass.cy_type}} new(): #}
{#         raise NotImplementedError("TODO :'(") #} #}
{#  #}
{#     def free(self): #}
{#         pythonscript_gdextension.object_destroy(self._gd_ptr) #}
{#         self._gd_ptr = NULL #}
{#  #}
{#     def __init__(self): #}
{#         raise RuntimeError( #}
{#             f"Use `new()` method to instantiate non-refcounted Godot object (and don't forget to free it !)" #}
{#         ) #}
{#  #}
{#     def __repr__(self): #}
{#         return f"<{type(self).__name__} wrapper on 0x{<size_t>self._gd_ptr:x}>" #}
{# {%   else %} #}
{#     pass #}
{# {% endif %} #}
{# {% endfor %} #}


cdef object _load_singleton(str name):
    cdef object cls = _load_class(name)
{# cdef GDExtensionObjectPtr gdobj = pythonscript_gdextension.global_get_singleton(&(<StringName>cls._gd_name)._gd_data) #}
    cdef gd_string_name_t gdname
    pythonscript_gdstringname_new(&gdname, name.encode())
    cdef GDExtensionObjectPtr gdobj = pythonscript_gdextension.global_get_singleton(&gdname)
    pythonscript_gdstringname_delete(&gdname)
    return cls._from_ptr(<size_t>gdobj)
{# {% for singleton in api.singletons %}
    cdef {{ singleton.type.py_type }} singleton_{{ singleton.name }} = {{ singleton.type.py_type }}.__new__({{ singleton.type.py_type }})
    singleton_{{ singleton.name }}._gd_ptr = pythonscript_gdextension.global_get_singleton("{{ singleton.original_name }}")
    globals()["{{ singleton.name }}"] = singleton_{{ singleton.name }}
{% endfor %} #}


cdef inline object _property_getter(object obj, object name):
    return _object_call((<GDObject>obj)._gd_ptr, "get", [name])


cdef inline void _property_setter(object obj, object name, object value):
    _object_call((<GDObject>obj)._gd_ptr, "set", [name, value])


cdef inline object _meth_call(object obj, object name, object args):
    return _object_call((<GDObject>obj)._gd_ptr, "call", [name, *args])


cdef object _load_class(str name):
    cdef StringName gdname = StringName(name)

    # Load our good friend ClassDB
    cdef StringName gdname_classdb = StringName("ClassDB")
    cdef GDExtensionObjectPtr classdb = pythonscript_gdextension.global_get_singleton(&gdname_classdb._gd_data)

    if not _object_call(classdb, "class_exists", [gdname]):
        raise RuntimeError(f"Class `{name}` doesn't exist in Godot !")

    print("loading", name)
    gdparent = _object_call(classdb, "get_parent_class", [gdname])
    parent = str(gdparent)
    if parent:
        parent_cls = _load_class(parent)
        bases = (parent_cls, )
    else:
        bases = (BaseGDObject, )

    attrs = {"_gd_name": gdname}
    ################################ TODO: meth["name"] is GDString, should use str/StringName instead

    def _generate_method(spec, py_meth_name):
        gd_meth_name = spec["name"]
        def _meth(self, *args):
            print(f"CALL {gd_meth_name!r} {args!r}")
            return _meth_call(self, gd_meth_name, args)
        _meth.__name__ = py_meth_name
        return _meth

    meths = _object_call(classdb, "class_get_method_list", [gdname])
    for meth in meths:
        meth_name = str(meth["name"])
        attrs[meth_name] = _generate_method(meth, meth_name)

    def _generate_property(spec):
        propname = spec["name"]
        @property
        def _property(self):
            print(f"GET {propname}")
            return _property_getter(self, propname)
        @_property.setter
        def _property(self, value):
            print(f"GET {propname} {value!r}")
            _property_setter(self, propname, value)
        _property.fget.__name__ = str(spec["name"])
        _property.fset.__name__ = str(spec["name"])
        return _property

    properties = _object_call(classdb, "class_get_property_list", [gdname])
    for prop in properties:
        attrs[str(prop["name"])] = _generate_property(prop)

    signals = _object_call(classdb, "class_get_signal_list", [gdname])
    # TODO

    return type(name, bases, attrs)


cdef object _object_call(GDExtensionObjectPtr obj, str meth, args):
    cdef gd_variant_t ret
    cdef GDExtensionCallError call_error

    # TODO: really inefficient to re-create StringName
    cdef StringName gdname_classdb = StringName("ClassDB")
    cdef GDExtensionObjectPtr classdb = pythonscript_gdextension.global_get_singleton(&gdname_classdb._gd_data)

    cdef StringName gdname_object = StringName("Object")
    cdef StringName gdname_call = StringName("call")
    cdef GDExtensionMethodBindPtr Object_call = pythonscript_gdextension.classdb_get_method_bind(&gdname_object._gd_data, &gdname_call._gd_data, {{ api.get_class_meth_hash("Object", "call") }})

    cdef GDExtensionInt args_with_meth_len = len(args) + 1
    if args_with_meth_len > 9:
        # TODO: handle this
        pythonscript_gdextension.print_error("more than 8 params is not supported !", "_object_call", "", 0)
        return None
    cdef gd_variant_t[9] variant_args
    cdef (gd_variant_t*)[9] variant_args_ptrs
    for i in range(args_with_meth_len):
        variant_args_ptrs[i] = &variant_args[i]

    # TODO: provide a helper for string name from Python str creation
    cdef gd_string_t meth_gdstr = gd_string_from_unchecked_pystr(meth)
    cdef gd_string_name_t meth_gdstrname = gd_string_name_new_from_string(&meth_gdstr)
    gd_string_del(&meth_gdstr)
    variant_args[0] = gd_string_name_into_variant(&meth_gdstrname)
    # Into conversion steals the owneship, so no need to delete meth_gdstrname

    for i, arg in enumerate(args, 1):
        if not gd_variant_steal_from_pyobj(arg, &variant_args[i]):
            raise TypeError(f"Parameter `{arg!r}` cannot be converted into a Godot Variant !")

    print(f"About to call {meth} {args!r}")

    pythonscript_gdextension.object_method_bind_call(
        Object_call,
        classdb,
        # Cast is required given autopxd2 incorrectly removes the const attributes
        # when converting gdextension_interface.c to .pxd
        <const void * const*>&variant_args_ptrs,
        args_with_meth_len,
        &ret,
        &call_error,
    )
    gd_variant_del(&variant_args[0])  # Only param we created without stealing ownership
    if call_error.error == GDEXTENSION_CALL_OK:
        return gd_variant_steal_into_pyobj(&ret)
        # No need to destroy ret given the conversion has stolen ownership on data !

    # TODO: improve ret error raised exception type ?
    elif call_error.error == GDEXTENSION_CALL_ERROR_INVALID_METHOD:
        raise RuntimeError(f"Error in Godot object method call: invalid method")

    elif call_error.error == GDEXTENSION_CALL_ERROR_INVALID_ARGUMENT:
        raise RuntimeError(f"Error in Godot object method call: invalid argument")

    elif call_error.error == GDEXTENSION_CALL_ERROR_TOO_MANY_ARGUMENTS  or call_error.error == GDEXTENSION_CALL_ERROR_TOO_FEW_ARGUMENTS:
        raise RuntimeError(f"Error in Godot object method call: expected {call_error.argument} arguments, got {call_error.expected}")

    elif call_error.error == GDEXTENSION_CALL_ERROR_INSTANCE_IS_NULL:
        raise RuntimeError(f"Error in Godot object method call: instance is null")

    else:
        raise RuntimeError(f"Unknown error in Godot object method call: Godot error code {call_error.error}")
