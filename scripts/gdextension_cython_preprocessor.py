import argparse
import textwrap
from pathlib import Path
import re
from typing import Optional, List, Dict
from dataclasses import dataclass


PRAGMA_RE = re.compile(r"^(?P<indentation>\s*)# godot_extension:\s+(?P<pragma>.*)$")
CLASS_RE = re.compile(r"^cdef class (?P<class_name>\w+)")
METHOD_RE = re.compile(
    r"^cdef\s+(inline\s+)?(?P<return_type>\w+)\s+(?P<method_name>\w+)\((?P<param>.*)\):"
)

INJECT_CODE_PRAGMA = "generate_code()"
AUTOGENERATED_HEADER = "*** Start of auto-generated code ***"
AUTOGENERATED_FOOTER = "*** End of auto-generated code ***"


@dataclass
class MethodDef:
    method_name: str
    is_staticmethod: bool
    is_const: bool
    return_type: str
    parameters: Dict[str, str]


@dataclass
class ClassDef:
    class_def_at_line: int
    class_name: str
    parent_class_name: str
    methods: List[MethodDef]
    inject_code_at_line: int


def generate_injected_code_method(spec: MethodDef, class_spec: ClassDef) -> str:
    code = f"""
@staticmethod
cdef void __godot_extension_class_meth_{spec.method_name}(
    void *method_userdata,
    GDExtensionClassInstancePtr p_instance,
    const GDNativeTypePtr *p_args,
    GDNativeTypePtr r_ret,
) with gil:
"""

    if spec.return_type == "void":
        code += "    "
    else:
        code += f"    (<{spec.return_type}*>r_ret)[0] = "
    if spec.is_staticmethod:
        code += f"{class_spec.class_name}.{spec.method_name}(\n"
    else:
        code += f"(<{class_spec.class_name}>p_instance).{spec.method_name}(\n"

    for _, param_type in spec.parameters.items():
        code += f"        (<{param_type}>p_args[0])[0],\n"
    code += "    )\n"

    return code


def generate_injected_code_register(spec: ClassDef) -> str:
    code = f"""
@staticmethod
def __godot_extension_unregister_class():
    unregister_extension_class(b"{spec.class_name}")

@staticmethod
cdef GDExtensionClassInstancePtr __godot_extension_new(void* p_userdata) with gil:
    cdef {spec.class_name} obj = {spec.class_name}()
    Py_INCREF(obj)
    return <PyObject*>obj

@staticmethod
cdef void __godot_extension_free(void* p_userdata, GDExtensionClassInstancePtr p_instance) with gil:
    Py_DECREF(<{spec.class_name}>p_instance)

@staticmethod
def __godot_extension_register_class():
    register_extension_class_creation(
        b"{spec.class_name}",
        b"{spec.parent_class_name}",
        &{spec.class_name}.__godot_extension_new,
        &{spec.class_name}.__godot_extension_free,
    )
"""
    for method in spec.methods:
        cooked_params = "["
        for param_name, param_type in method.parameters.items():
            cooked_params += "("
            cooked_params += f'b"{param_type}", b"{param_name}"'
            cooked_params += "), "
        cooked_params += "]"

        code += textwrap.indent(
            f"""
register_extension_class_method(
    b"{spec.class_name}",
    b"{method.method_name}",
    &{spec.class_name}.__godot_extension_class_meth_{method.method_name},
    {'True' if method.is_staticmethod else 'False'},
    b"{method.return_type}",
    {cooked_params}
)
""",
            prefix="    ",
        )

    return code


def generate_injected_code(spec: ClassDef) -> str:
    code = ""

    for method_spec in spec.methods:
        method_code = generate_injected_code_method(method_spec, spec)
        code += textwrap.indent(method_code, prefix="    ")

    register_code = generate_injected_code_register(spec)
    code += textwrap.indent(register_code, prefix="    ")

    return code


def extract_classes_from_code(code_lines: List[str]) -> List[ClassDef]:
    code_lines = enumerate(code_lines)
    classes: List[ClassDef] = []

    current_class: Optional[ClassDef] = None
    for i, line in code_lines:
        match = PRAGMA_RE.match(line)
        if not match:
            continue

        pragma = match.group("pragma").strip()
        if pragma == INJECT_CODE_PRAGMA:
            if current_class is None:
                raise RuntimeError(
                    f"Line {i + 1}: `# godot_extension: {pragma}` must be within a `# godot_extension: class(...)` pragma"
                )

            if current_class.inject_code_at_line != -1:
                raise RuntimeError(
                    f"Line {i + 1}: `# godot_extension: {pragma}` already defined at line {current_class.inject_code_site} for class `{current_class.class_name}`"
                )

            current_class.inject_code_at_line = i

        elif pragma in (AUTOGENERATED_HEADER, AUTOGENERATED_FOOTER):
            continue

        else:

            def _method(const: bool = False) -> MethodDef:
                if current_class is None:
                    raise RuntimeError(
                        f"`# godot_extension: method(...)` must be within a `# godot_extension: class(...)` pragma"
                    )

                if not isinstance(const, bool):
                    raise RuntimeError("`const` parameter must be a boolean")

                is_const = const
                try:
                    _, line = next(code_lines)
                    is_staticmethod = line.strip() == "@staticmethod"
                    if is_staticmethod:
                        _, line = next(code_lines)
                except StopIteration:
                    raise RuntimeError("unexpected end of file")

                if line.strip().startswith("@"):
                    raise RuntimeError("Only `@staticmethod` decorator is supported")

                # Retrieve the parameters that can span accross multiple lines
                try:
                    current_line = iter(line[line.index("(") + 1 :])
                    meth_signature = line[: line.index("(") + 1].strip()
                except ValueError:
                    raise RuntimeError(
                        f"expected method signature `cdef [inline] gd_xxx_t foo({'' if is_staticmethod else 'self, '}, gd_yyy_t bar, ...)"
                    )
                open_parenthesises = 1
                while open_parenthesises > 0:
                    for c in current_line:
                        if c == "(":
                            open_parenthesises += 1
                        elif c == ")":
                            open_parenthesises -= 1
                        meth_signature += c
                    if open_parenthesises:
                        try:
                            _, current_line = iter(next(code_lines))
                        except StopIteration:
                            raise RuntimeError("unexpected end of file")

                match = METHOD_RE.match(meth_signature)
                if not match:
                    raise RuntimeError(
                        f"expected method signature `cdef [inline] gd_xxx_t foo({'' if is_staticmethod else 'self, '}, gd_yyy_t bar, ...)"
                    )

                params = {}
                for i, raw_param in enumerate(match.group("param").split(",")):
                    if i == 0 and not is_staticmethod:
                        if raw_param != "self":
                            raise RuntimeError(
                                "expected first paramater for non static method to be `self`"
                            )
                        continue

                    try:
                        param_type, param_name = raw_param.split()
                    except ValueError:
                        raise RuntimeError(f"bad parameter {raw_param!r}")
                    params[param_name] = param_type

                current_class.methods.append(
                    MethodDef(
                        method_name=match.group("method_name"),
                        is_staticmethod=is_staticmethod,
                        is_const=is_const,
                        return_type=match.group("return_type"),
                        parameters=params,
                    )
                )

            def _class(parent: str) -> ClassDef:
                nonlocal current_class
                nonlocal classes

                if not isinstance(parent, str):
                    raise RuntimeError("`parent` parameter must be a string")

                try:
                    class_def_at_line, line1 = next(code_lines)
                    _, line2 = next(code_lines)

                    match = CLASS_RE.match(line2)
                    if line1.strip() != "@cython.final" or not match:
                        raise RuntimeError("expected `@cython.final` decorated cdef class")

                except StopIteration:
                    raise RuntimeError("unexpected end of file")

                current_class = ClassDef(
                    class_def_at_line=class_def_at_line,
                    class_name=match.group("class_name"),
                    parent_class_name=parent,
                    methods=[],
                    inject_code_at_line=-1,
                )
                classes.append(current_class)

            try:
                eval("_" + pragma, {"_method": _method, "_class": _class})
            except NameError as exc:
                raise RuntimeError(f"Line {i + 1}: Unknown pragma `{line.strip()}`") from exc
            except Exception as exc:
                raise RuntimeError(
                    f"Line {i + 1}: Invalid pragma `{line.strip()}` ({exc})"
                ) from exc

    return classes


def parse_code(code: str) -> str:
    # First pass: remove old autogenerate code if any
    iter_lines = enumerate(code.splitlines())
    code_lines = []
    currently_in_autogenerated_code = False
    for i, line in iter_lines:
        match = PRAGMA_RE.match(line)
        if match:
            pragma = match.group("pragma").strip()
            if pragma == AUTOGENERATED_HEADER:
                if currently_in_autogenerated_code:
                    raise RuntimeError(f"Line {i + 1}: Nested autogenerated header are not allowed")
                currently_in_autogenerated_code = True
                continue
            elif pragma == AUTOGENERATED_FOOTER:
                if not currently_in_autogenerated_code:
                    raise RuntimeError(
                        f"Line {i + 1}: Found autogenerated footer without matching header"
                    )
                currently_in_autogenerated_code = False
                continue

        if not currently_in_autogenerated_code:
            code_lines.append(line)

    # Second pass: find `# godot_extension: ...` pragma instructions
    classes = extract_classes_from_code(code_lines)

    # Last pass: inject generated code in the `# godot_extension: inject_code_site` pragmas
    for klass in reversed(classes):
        if klass.inject_code_at_line == -1:
            raise RuntimeError(
                f"Line {klass.class_def_at_line}: Missing pragam `# godot_extension: inject_code_site` for class `{klass.class_name}`"
            )
        code_lines = (
            code_lines[: klass.inject_code_at_line + 1]
            + [
                f"    # godot_extension: {AUTOGENERATED_HEADER}",
                generate_injected_code(klass),
                f"    # godot_extension: {AUTOGENERATED_FOOTER}",
            ]
            + code_lines[klass.inject_code_at_line + 1 :]
        )

    code = "\n".join(code_lines)
    if not code.endswith("\n"):
        code += "\n"
    return code


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Generate Godot extension class boilerplate for Cython code"
    )
    parser.add_argument(
        "input",
        type=Path,
    )
    parser.add_argument(
        "--output",
        "-o",
        type=Path,
    )
    parser.add_argument(
        "--debug",
        action="store_true",
    )
    args = parser.parse_args()
    if args.input.suffix not in (".pyx", ".pxi"):
        raise SystemExit("Expected .pyx/.pxi file as input")

    input_code = args.input.read_text(encoding="utf8")
    try:
        output_code = parse_code(input_code)
    except RuntimeError as exc:
        if args.debug:
            raise
        else:
            raise SystemExit(str(exc)) from exc
    if args.output:
        args.output.write_text(output_code, encoding="utf8")
    else:
        args.input.write_text(output_code, encoding="utf8")
